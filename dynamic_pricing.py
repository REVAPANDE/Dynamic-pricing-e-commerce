# -*- coding: utf-8 -*-
"""dynamic_pricing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k59Eez3io35Wle8Pm4b8FfNquvfX-gjo
"""

from google.colab import drive
drive.mount('/content/drive')

!unzip -o "/content/drive/MyDrive/archive (1).zip" -d olist_data

!ls olist_data

import pandas as pd

orders = pd.read_csv("olist_data/olist_orders_dataset.csv", parse_dates=["order_purchase_timestamp"])
items = pd.read_csv("olist_data/olist_order_items_dataset.csv")
products = pd.read_csv("olist_data/olist_products_dataset.csv")

print(orders.shape, items.shape, products.shape)
orders.head()

# Merge purchase date into order items
items = items.merge(
    orders, # Merge the entire orders DataFrame to ensure 'order_purchase_timestamp' is included
    on="order_id",
    how="left"
)

# Extract only the date part
items["date"] = pd.to_datetime(items["order_purchase_timestamp"].dt.date)

# Aggregate to get daily product sales
agg = items.groupby(["product_id", "date"], as_index=False).agg(
    units_sold=("order_id", "count"),   # number of orders for the product on that date
    price=("price", "mean")             # average selling price
)

# Add category from products table
products_small = products[["product_id", "product_category_name"]].rename(
    columns={"product_category_name": "category"}
)
df = agg.merge(products_small, on="product_id", how="left")

# Fill missing category names with "unknown"
df["category"] = df["category"].fillna("unknown")

print(df.shape)
df.head()

import numpy as np

rng = np.random.default_rng(42)  # for reproducibility

# --- Competitor price (simulated) ---
# Take median price of each category and adjust randomly
cat_med = df.groupby("category")["price"].median().rename("cat_med_price")
df = df.merge(cat_med, on="category", how="left")
df["competitor_price"] = (df["cat_med_price"] * rng.uniform(0.9, 1.15, size=len(df))).clip(10, 10000)

# --- Cost price (simulated) ---
# Assume cost is between 50% and 80% of selling price
df["cost"] = df["price"] * rng.uniform(0.5, 0.8, size=len(df))

# --- Time-based features ---
df["day_of_week"] = df["date"].dt.dayofweek
df["is_weekend"] = (df["day_of_week"] >= 5).astype(int)
df["month"] = df["date"].dt.month
df["seasonality"] = 1.0 + 0.25 * np.sin(2 * np.pi * (df["date"].dt.dayofyear) / 365.0)

# --- Promo flag (simulated) ---
df["promo"] = (rng.uniform(0, 1, size=len(df)) < 0.15).astype(int)

# --- Revenue ---
df["revenue"] = df["price"] * df["units_sold"]

print(df.shape)
df.head()

# Sort for lag calculations
df = df.sort_values(["product_id", "date"]).reset_index(drop=True)

# Relative price & price gap
df["rel_price"] = df["price"] / df["competitor_price"]
df["price_gap"] = df["price"] - df["competitor_price"]

# Create lag & rolling features per product
parts = []
for pid, group in df.groupby("product_id"):
    g = group.copy()
    g["lag_units_1"] = g["units_sold"].shift(1)  # yesterday's sales
    g["lag_units_7"] = g["units_sold"].shift(7)  # last week sales
    g["roll_units_7"] = g["units_sold"].rolling(7, min_periods=1).mean()
    g["roll_units_14"] = g["units_sold"].rolling(14, min_periods=1).mean()
    parts.append(g)

df = pd.concat(parts, ignore_index=True)

# Fill missing lag/rolling values
for col in ["lag_units_1", "lag_units_7", "roll_units_7", "roll_units_14"]:
    df[col] = df[col].fillna(df[col].median())

print(df.shape)
df.head()

# Target variable
target = "units_sold"

# Features for the ML model
features = [
    "category", "cost", "price", "competitor_price", "promo",
    "day_of_week", "is_weekend", "seasonality", "rel_price", "price_gap",
    "lag_units_1", "lag_units_7", "roll_units_7", "roll_units_14", "month"
]

X = df[features]
y = df[target].astype(float)

# Train/test split (80% train, 20% test)
split_idx = int(len(df) * 0.8)
X_train, X_test = X.iloc[:split_idx], X.iloc[split_idx:]
y_train, y_test = y.iloc[:split_idx], y.iloc[split_idx:]

print(f"Train size: {X_train.shape}, Test size: {X_test.shape}")

from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error, r2_score
import numpy as np

# Identify numeric and categorical columns
num_cols = [c for c in X_train.columns if X_train[c].dtype != "object"]
cat_cols = [c for c in X_train.columns if X_train[c].dtype == "object"]

# Preprocessing: scale numeric, one-hot encode categorical
preprocess = ColumnTransformer([
    ("num", StandardScaler(), num_cols),
    ("cat", OneHotEncoder(handle_unknown="ignore"), cat_cols)
])

# Models
models = {
    "LinearRegression": Pipeline([("prep", preprocess), ("mdl", LinearRegression())]),
    "RandomForest": Pipeline([("prep", preprocess), ("mdl", RandomForestRegressor(n_estimators=200, random_state=42, n_jobs=-1))]),
    "XGBoost": Pipeline([("prep", preprocess), ("mdl", XGBRegressor(n_estimators=400, learning_rate=0.05, max_depth=6, random_state=42, tree_method="hist", n_jobs=-1))])
}

# Train & evaluate
results = []
for name, pipe in models.items():
    pipe.fit(X_train, y_train)
    preds = pipe.predict(X_test)
    rmse = np.sqrt(mean_squared_error(y_test, preds))  # manual RMSE calc
    r2 = r2_score(y_test, preds)
    results.append((name, rmse, r2))
    print(f"{name}: RMSE = {rmse:.2f}, R² = {r2:.2f}")

def optimize_price(model, product_features, price_range=None, step=1.0):
    """
    model: trained pipeline from Step 8
    product_features: dict of feature values for one product
    price_range: tuple (min_price, max_price) or None for auto ±20%
    step: price increment for search
    """
    import pandas as pd
    import numpy as np

    # If no range given, set ±20% around current price
    current_price = product_features["price"]
    if price_range is None:
        min_price = max(1.0, current_price * 0.8)
        max_price = current_price * 1.2
    else:
        min_price, max_price = price_range

    # Try all candidate prices
    candidates = []
    for p in np.arange(min_price, max_price, step):
        temp = product_features.copy()
        temp["price"] = p
        temp["rel_price"] = p / temp["competitor_price"]
        temp["price_gap"] = p - temp["competitor_price"]
        candidates.append(temp)

    df_candidates = pd.DataFrame(candidates)
    df_candidates["pred_units"] = model.predict(df_candidates)
    df_candidates["pred_revenue"] = df_candidates["pred_units"] * df_candidates["price"]

    # Best price
    best_row = df_candidates.loc[df_candidates["pred_revenue"].idxmax()]
    return best_row[["price", "pred_units", "pred_revenue"]], df_candidates

# Example: pick the best model from Step 8 (replace with your best)
best_model_name = sorted(results, key=lambda x: x[1])[0][0]  # lowest RMSE
best_model = models[best_model_name]

# Example product to optimize
example = X_test.iloc[0].to_dict()
opt_price, all_prices = optimize_price(best_model, example, step=0.5)

print(f"Best price: {opt_price['price']:.2f}")
print(f"Predicted units sold: {opt_price['pred_units']:.2f}")
print(f"Predicted revenue: {opt_price['pred_revenue']:.2f}")

# Apply optimization to multiple products
optimized_results = []
for i in range(len(X_test)):
    product_features = X_test.iloc[i].to_dict()
    opt_price, _ = optimize_price(best_model, product_features, step=1.0)
    actual_revenue = y_test.iloc[i] * product_features["price"]
    optimized_results.append({
        "product_index": i,
        "current_price": product_features["price"],
        "optimized_price": opt_price["price"],
        "current_revenue": actual_revenue,
        "optimized_revenue": opt_price["pred_revenue"]
    })

opt_df = pd.DataFrame(optimized_results)

# Calculate gain
opt_df["revenue_gain"] = opt_df["optimized_revenue"] - opt_df["current_revenue"]

print(opt_df.head())

# Summary stats
gain_mean = opt_df["revenue_gain"].mean()
gain_total = opt_df["revenue_gain"].sum()
print(f"Average revenue gain per product: {gain_mean:.2f}")
print(f"Total revenue gain: {gain_total:.2f}")

# Plot distribution of gains
import matplotlib.pyplot as plt

plt.figure(figsize=(8,5))
plt.hist(opt_df["revenue_gain"], bins=30, color="skyblue", edgecolor="black")
plt.axvline(0, color="red", linestyle="--")
plt.title("Distribution of Revenue Gains from Price Optimization")
plt.xlabel("Revenue Gain")
plt.ylabel("Number of Products")
plt.show()

import zipfile
import os

# 1. Export optimized pricing table
opt_df.to_csv("optimized_prices.csv", index=False)
print("✅ Optimized pricing table saved as optimized_prices.csv")

# 2. Save notebook in Colab (manual download required)
# In Colab: File → Download → Download .ipynb
# or run:
# from google.colab import files
# files.download('Dynamic_Pricing_Model.ipynb')

# 3. Create ZIP with dataset + results
with zipfile.ZipFile("Dynamic_Pricing_Submission.zip", "w") as zipf:
    zipf.write("optimized_prices.csv")
    # Add dataset files if needed
    for file in os.listdir("olist_data"):
        zipf.write(os.path.join("olist_data", file), arcname=file)

print("✅ Created Dynamic_Pricing_Submission.zip")

# Optional: Download the ZIP directly in Colab
# from google.colab import files
# files.download("Dynamic_Pricing_Submission.zip")